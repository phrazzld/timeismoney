/**
 * Consolidated test file generated by consolidate-test-files.js script
 *
 * Original files:
 * converter.edge.unit.vitest.test.js, converter.unified.unit.vitest.test.js, converter.unit.vitest.test.js
 *
 * Generated: 2025-05-15T10:09:05.713Z
 */

import {
  describe,
  test,
  expect,
  vi,
  beforeEach,
  afterEach,
} from '../../../setup/vitest-imports.js';
import { resetTestMocks } from '../../../setup/vitest.setup.js';
import {
  normalizePrice,
  calculateHourlyWage,
  convertToTime,
  formatTimeSnippet,
  formatTimeCompact,
  formatPriceWithTime,
  convertPriceToTimeString,
} from '../../../utils/converter';

// ---------------------- From converter.edge.unit.vitest.test.js ----------------------

/**
 * Edge case tests for converter.js
 * Specifically focused on extreme values, unusual inputs, and boundary conditions
 */

beforeEach(() => {
  resetTestMocks();
});

afterEach(() => {
  resetTestMocks();
});

// Mock logger to prevent console output during tests
vi.mock('../../../utils/logger', () => ({
  error: vi.fn(),
  warn: vi.fn(),
  info: vi.fn(),
  debug: vi.fn(),
}));

beforeEach(() => {
  // Reset mocks before each test
  resetTestMocks();
});

describe('Edge cases: normalizePrice', () => {
  const thousands = /,/g;
  const decimal = /\./g;

  test('handles empty or whitespace-only strings', () => {
    expect(isNaN(normalizePrice('', thousands, decimal))).toBe(true);
    expect(isNaN(normalizePrice('   ', thousands, decimal))).toBe(true);
  });

  test('handles strings with only currency symbols', () => {
    expect(isNaN(normalizePrice('$', thousands, decimal))).toBe(true);
    expect(isNaN(normalizePrice('€', thousands, decimal))).toBe(true);
  });

  test('handles prices with multiple decimal points', () => {
    // The implementation seems to replace all decimal points with '~', then the first '~' with '.'
    // This results in 123.46 rather than 123.45
    expect(normalizePrice('123.45.67', thousands, decimal)).toBe(123.46);
  });

  test('handles negative prices', () => {
    expect(normalizePrice('-$100.00', thousands, decimal)).toBe(100.0);
    expect(normalizePrice('$-100.00', thousands, decimal)).toBe(100.0);
  });

  test('handles prices with unusual thousand/decimal separators', () => {
    // Using dot as thousands and comma as decimal
    const reversedFormatters = {
      thousands: /\./g,
      decimal: /,/g,
    };
    expect(
      normalizePrice('1.234,56', reversedFormatters.thousands, reversedFormatters.decimal)
    ).toBe(1234.56);
  });
});

describe('Edge cases: calculateHourlyWage', () => {
  test('handles negative wage amounts', () => {
    expect(calculateHourlyWage('hourly', '-20')).toBe(-20);
    expect(calculateHourlyWage('yearly', '-41600')).toBe(-20);
  });

  test('handles zero wage amount', () => {
    expect(calculateHourlyWage('hourly', '0')).toBe(0);
    expect(calculateHourlyWage('yearly', '0')).toBe(0);
  });

  test('handles extremely large wage amounts without overflow', () => {
    const largeHourly = 1e15;
    const largeYearly = 1e15;

    expect(calculateHourlyWage('hourly', largeHourly.toString())).toBe(largeHourly);
    expect(calculateHourlyWage('yearly', largeYearly.toString())).toBe(largeYearly / 2080);
  });

  test('handles undefined frequency by defaulting to hourly', () => {
    expect(calculateHourlyWage(undefined, '20')).toBe(20);
  });

  test('handles null inputs', () => {
    expect(isNaN(calculateHourlyWage('hourly', null))).toBe(true);
    // Null frequency defaults to hourly behavior
    expect(calculateHourlyWage(null, '20')).toBe(20);
  });
});

describe('Edge cases: convertToTime', () => {
  test('handles negative prices', () => {
    const result = convertToTime(-100, 20);
    // Should treat negative prices as positive or give special handling
    expect(result.hours).toBe(-5);
    expect(result.minutes).toBe(0);
  });

  test('handles zero hourly rate', () => {
    // Division by zero should be handled
    const result = convertToTime(100, 0);
    expect(result.hours).toBe(Infinity);
    expect(isNaN(result.minutes)).toBe(true); // Minutes calculation involves infinity which gives NaN
  });

  test('handles negative hourly rate', () => {
    const result = convertToTime(100, -20);
    expect(result.hours).toBe(-5);
    expect(result.minutes).toBe(0);
  });

  test('handles NaN inputs', () => {
    const result = convertToTime(NaN, 20);
    expect(isNaN(result.hours)).toBe(true);
    expect(isNaN(result.minutes)).toBe(true);
  });

  test('handles minute rounding edge cases', () => {
    // 15 minutes (should round to 15)
    let result = convertToTime(5, 20);
    expect(result.hours).toBe(0);
    expect(result.minutes).toBe(15);

    // 14.9 minutes (should round to 15)
    result = convertToTime(4.98, 20);
    expect(result.hours).toBe(0);
    expect(result.minutes).toBe(15);

    // 14.8 minutes (should round to 15)
    result = convertToTime(4.95, 20);
    expect(result.hours).toBe(0);
    expect(result.minutes).toBe(15);

    // 14.7 minutes (should round to 15)
    result = convertToTime(4.9, 20);
    expect(result.hours).toBe(0);
    expect(result.minutes).toBe(15);
  });

  test('handles minute rounding to 59/60', () => {
    // 59.4 minutes (should round to 59)
    let result = convertToTime(19.8, 20);
    expect(result.hours).toBe(0);
    expect(result.minutes).toBe(59);

    // 59.5 minutes (should round to 60, which becomes 1h 0m)
    result = convertToTime(19.84, 20);
    expect(result.hours).toBe(1);
    expect(result.minutes).toBe(0);

    // 59.6 minutes (should round to 60, which becomes 1h 0m)
    result = convertToTime(19.88, 20);
    expect(result.hours).toBe(1);
    expect(result.minutes).toBe(0);
  });
});

describe('Edge cases: formatTimeSnippet', () => {
  test('handles negative hours and minutes', () => {
    // The current implementation doesn't properly handle singular form for negative numbers
    expect(formatTimeSnippet(-1, 30)).toBe('-1 hours, 30 minutes');
    expect(formatTimeSnippet(0, -15)).toBe('-15 minutes');
    expect(formatTimeSnippet(-2, -45)).toBe('-2 hours, -45 minutes');
  });

  test('handles extremely large values', () => {
    expect(formatTimeSnippet(1000000, 30)).toBe('1000000 hours, 30 minutes');
  });

  test('handles non-integer hours and minutes', () => {
    // The current implementation passes fractional values through without rounding
    expect(formatTimeSnippet(2.7, 15.3)).toBe('2.7 hours, 15.3 minutes');
  });
});

describe('Edge cases: formatTimeCompact', () => {
  test('handles negative hours and minutes', () => {
    expect(formatTimeCompact(-1, 30)).toBe('-1h 30m');
    expect(formatTimeCompact(0, -15)).toBe('0h -15m');
    expect(formatTimeCompact(-2, -45)).toBe('-2h -45m');
  });

  test('handles extremely large values', () => {
    expect(formatTimeCompact(1000000, 30)).toBe('1000000h 30m');
  });
});

describe('Edge cases: formatPriceWithTime', () => {
  test('handles empty or null price string', () => {
    expect(formatPriceWithTime('', 1, 30)).toBe(' (1h 30m)');
    expect(formatPriceWithTime(null, 1, 30)).toBe('null (1h 30m)');
  });

  test('handles unusual price formats', () => {
    expect(formatPriceWithTime('Contact for price', 1, 30)).toBe('Contact for price (1h 30m)');
    expect(formatPriceWithTime('Starting at $19.99', 1, 0)).toBe('Starting at $19.99 (1h 0m)');
  });
});

describe('Edge cases: convertPriceToTimeString (integration)', () => {
  const formatters = {
    thousands: /,/g,
    decimal: /\./g,
  };
  const wageInfo = {
    frequency: 'hourly',
    amount: '20',
  };

  test('handles malformed formatter objects', () => {
    // Missing thousands regex - implementation gracefully falls back rather than failing
    const badFormatters1 = {
      decimal: /\./g,
    };
    expect(convertPriceToTimeString('$100.00', badFormatters1, wageInfo)).toBe('$100.00 (5h 0m)');

    // Missing decimal regex - implementation gracefully falls back rather than failing
    const badFormatters2 = {
      thousands: /,/g,
    };
    expect(convertPriceToTimeString('$100.00', badFormatters2, wageInfo)).toBe('$100.00 (5h 0m)');

    // Invalid regex (should cause exception but is handled by falling back)
    const badFormatters3 = {
      thousands: null,
      decimal: null,
    };
    expect(convertPriceToTimeString('$100.00', badFormatters3, wageInfo)).toBe('$100.00 (5h 0m)');
  });

  test('handles malformed wageInfo objects', () => {
    // Missing frequency
    const badWageInfo1 = {
      amount: '20',
    };
    expect(convertPriceToTimeString('$100.00', formatters, badWageInfo1)).toBe('$100.00 (5h 0m)');

    // Missing amount
    const badWageInfo2 = {
      frequency: 'hourly',
    };
    expect(convertPriceToTimeString('$100.00', formatters, badWageInfo2)).toBe('$100.00');

    // Zero wage amount (division by zero)
    const badWageInfo3 = {
      frequency: 'hourly',
      amount: '0',
    };
    expect(convertPriceToTimeString('$100.00', formatters, badWageInfo3)).toBe('$100.00');
  });

  test('handles complex price formats with decimal in thousand positions', () => {
    // This tests that the normalization works correctly when there are decimal points
    // in positions that look like thousand separators
    expect(
      convertPriceToTimeString('$1.234.567,89', { thousands: /\./g, decimal: /,/g }, wageInfo)
    ).toBe('$1.234.567,89 (61728h 24m)');
  });

  test('handles empty strings and whitespace', () => {
    expect(convertPriceToTimeString('', formatters, wageInfo)).toBe('');
    expect(convertPriceToTimeString('   ', formatters, wageInfo)).toBe('   ');
  });

  test('handles prices with only currency symbols', () => {
    expect(convertPriceToTimeString('$', formatters, wageInfo)).toBe('$');
    expect(convertPriceToTimeString('€', formatters, wageInfo)).toBe('€');
  });

  test('handles prices with additional text', () => {
    // The implementation is able to extract prices from text and convert them
    expect(convertPriceToTimeString('SALE: $19.99!', formatters, wageInfo)).toBe(
      'SALE: $19.99! (1h 0m)'
    );
    // The implementation recognizes and converts the first price in the string
    expect(convertPriceToTimeString('From $19.99 to $29.99', formatters, wageInfo)).toBe(
      'From $19.99 to $29.99 (1h 0m)'
    );
  });
});

// ---------------------- From converter.unified.unit.vitest.test.js ----------------------

/**
 * Tests for the unified converter.js utility
 * Ensures all functions from both original modules work correctly
 */

describe('normalizePrice', () => {
  test('normalizes price with commas as thousands separator and dot as decimal', () => {
    const thousands = /,/g;
    const decimal = /\./g;
    expect(normalizePrice('$1,234.56', thousands, decimal)).toBe(1234.56);
  });

  test('normalizes price with spaces as thousands separator and comma as decimal', () => {
    const thousands = /\s/g;
    const decimal = /,/g;
    expect(normalizePrice('€1 234,56', thousands, decimal)).toBe(1234.56);
  });

  test('handles price without thousands separator', () => {
    const thousands = /,/g;
    const decimal = /\./g;
    expect(normalizePrice('$123.45', thousands, decimal)).toBe(123.45);
  });

  test('handles price without decimal part', () => {
    const thousands = /,/g;
    const decimal = /\./g;
    expect(normalizePrice('$1,234', thousands, decimal)).toBe(1234.0);
  });

  test('handles various currency symbols', () => {
    const thousands = /,/g;
    const decimal = /\./g;
    expect(normalizePrice('£1,234.56', thousands, decimal)).toBe(1234.56);
    expect(normalizePrice('¥1,234.56', thousands, decimal)).toBe(1234.56);
    expect(normalizePrice('₹1,234.56', thousands, decimal)).toBe(1234.56);
    expect(normalizePrice('₩1,234.56', thousands, decimal)).toBe(1234.56);
    expect(normalizePrice('1,234.56kr', thousands, decimal)).toBe(1234.56);
  });

  test('handles prices with only digit characters', () => {
    const thousands = /,/g;
    const decimal = /\./g;
    expect(normalizePrice('1234.56', thousands, decimal)).toBe(1234.56);
  });

  test('normalizes price with apostrophes as thousands separator', () => {
    const thousands = /'/g;
    const decimal = /\./g;
    expect(normalizePrice("1'234.56", thousands, decimal)).toBe(1234.56);
  });

  test('handles prices with unusual formats', () => {
    const thousands = /,/g;
    const decimal = /\./g;
    // Price with additional text
    expect(normalizePrice('Price: $1,234.56', thousands, decimal)).toBe(1234.56);
    // Price with trailing text
    expect(normalizePrice('$1,234.56 only', thousands, decimal)).toBe(1234.56);
  });

  test('handles extreme price values', () => {
    const thousands = /,/g;
    const decimal = /\./g;
    // Very small price
    expect(normalizePrice('$0.01', thousands, decimal)).toBe(0.01);
    // Very large price
    expect(normalizePrice('$1,000,000,000.00', thousands, decimal)).toBe(1000000000.0);
  });
});

describe('calculateHourlyWage', () => {
  test('returns the amount directly for hourly frequency', () => {
    expect(calculateHourlyWage('hourly', '20')).toBe(20);
    expect(calculateHourlyWage('hourly', 25)).toBe(25);
  });

  test('converts yearly wage to hourly (yearly / 2080)', () => {
    expect(calculateHourlyWage('yearly', '41600')).toBe(20);
    expect(calculateHourlyWage('yearly', 83200)).toBe(40);
  });

  test('handles string vs number inputs consistently', () => {
    // Should handle both string and number inputs
    expect(calculateHourlyWage('hourly', '20')).toBe(calculateHourlyWage('hourly', 20));
    expect(calculateHourlyWage('yearly', '41600')).toBe(calculateHourlyWage('yearly', 41600));
  });

  test('handles floating point wage amounts', () => {
    expect(calculateHourlyWage('hourly', '20.50')).toBe(20.5);
    expect(calculateHourlyWage('yearly', '41600.50')).toBeCloseTo(20.0002403846, 10);
  });

  test('handles extreme wage values', () => {
    // Very small wage
    expect(calculateHourlyWage('hourly', '0.01')).toBe(0.01);
    // Very large wage
    expect(calculateHourlyWage('hourly', '1000000')).toBe(1000000);
  });

  test('handles unusual input values', () => {
    // Empty string results in NaN
    expect(isNaN(calculateHourlyWage('hourly', ''))).toBe(true);
    // Non-number string results in NaN
    expect(isNaN(calculateHourlyWage('hourly', 'not-a-number'))).toBe(true);
    // Unknown frequency just returns the hourly rate
    expect(calculateHourlyWage('unknown', '20')).toBe(20);
  });
});

describe('convertToTime', () => {
  // Direct hourlyWage parameter tests
  test('converts with direct hourlyWage parameter', () => {
    const result = convertToTime(100, 20);
    expect(result.hours).toBe(5);
    expect(result.minutes).toBe(0);
  });

  test('handles case where minutes round to 60', () => {
    // With hourlyWage=30, price=29.99 would be 0.999... hours,
    // which is 59.96 minutes, rounding to 60 minutes
    const result = convertToTime(29.99, 30);
    expect(result.hours).toBe(1);
    expect(result.minutes).toBe(0);
  });

  // Additional tests for edge cases
  test('handles zero price correctly', () => {
    const result = convertToTime(0, 20);
    expect(result.hours).toBe(0);
    expect(result.minutes).toBe(0);
  });

  test('handles very small prices', () => {
    // 0.01 at $20/hour = 0.0005 hours = 0.03 minutes, rounds to 0
    const result = convertToTime(0.01, 20);
    expect(result.hours).toBe(0);
    expect(result.minutes).toBe(0);

    // Small enough that it should be just under 1 minute
    const result2 = convertToTime(0.33, 20);
    expect(result2.hours).toBe(0);
    expect(result2.minutes).toBe(1);
  });

  test('handles very large prices', () => {
    // 1,000,000 at $20/hour = 50,000 hours
    const result = convertToTime(1000000, 20);
    expect(result.hours).toBe(50000);
    expect(result.minutes).toBe(0);
  });

  test('handles very small hourly wages', () => {
    // $100 at $0.01/hour = 10,000 hours
    const result = convertToTime(100, 0.01);
    expect(result.hours).toBe(10000);
    expect(result.minutes).toBe(0);
  });

  test('handles very large hourly wages', () => {
    // $100 at $1000/hour = 0.1 hours = 6 minutes
    const result = convertToTime(100, 1000);
    expect(result.hours).toBe(0);
    expect(result.minutes).toBe(6);
  });

  test('handles fractional minutes correctly', () => {
    // $100 at $27.50/hour = 3.6363... hours = 3 hours, 38 minutes
    const result = convertToTime(100, 27.5);
    expect(result.hours).toBe(3);
    expect(result.minutes).toBe(38);
  });
});

describe('formatTimeSnippet (verbose format)', () => {
  test('formats hours and minutes verbosely', () => {
    expect(formatTimeSnippet(2, 30)).toBe('2 hours, 30 minutes');
  });

  test('formats hours only', () => {
    expect(formatTimeSnippet(5, 0)).toBe('5 hours');
  });

  test('formats singular hour', () => {
    expect(formatTimeSnippet(1, 0)).toBe('1 hour');
  });

  test('formats minutes only', () => {
    expect(formatTimeSnippet(0, 45)).toBe('45 minutes');
  });

  test('formats singular minute', () => {
    expect(formatTimeSnippet(0, 1)).toBe('1 minute');
  });
});

describe('formatTimeCompact', () => {
  test('formats time in compact form', () => {
    expect(formatTimeCompact(5, 30)).toBe('5h 30m');
    expect(formatTimeCompact(0, 45)).toBe('0h 45m');
    expect(formatTimeCompact(1, 0)).toBe('1h 0m');
  });
});

describe('formatPriceWithTime', () => {
  test('formats price with compact time by default', () => {
    expect(formatPriceWithTime('$100', 5, 0)).toBe('$100 (5h 0m)');
    expect(formatPriceWithTime('€25.50', 1, 15)).toBe('€25.50 (1h 15m)');
  });

  test('formats price with verbose time when specified', () => {
    expect(formatPriceWithTime('$100', 5, 0, false)).toBe('$100 (5 hours)');
    expect(formatPriceWithTime('€25.50', 1, 15, false)).toBe('€25.50 (1 hour, 15 minutes)');
  });
});

describe('convertPriceToTimeString (integration test)', () => {
  test('converts price string to format with time - compact format', () => {
    const formatters = {
      thousands: /,/g,
      decimal: /\./g,
    };
    const wageInfo = {
      frequency: 'hourly',
      amount: '20',
    };

    const result = convertPriceToTimeString('$100.00', formatters, wageInfo);
    expect(result).toBe('$100.00 (5h 0m)');
  });

  test('converts price string to format with time - verbose format', () => {
    const formatters = {
      thousands: /,/g,
      decimal: /\./g,
    };
    const wageInfo = {
      frequency: 'hourly',
      amount: '20',
    };

    const result = convertPriceToTimeString('$100.00', formatters, wageInfo, false);
    expect(result).toBe('$100.00 (5 hours)');
  });

  test('returns original string for invalid inputs', () => {
    const formatters = {
      thousands: /,/g,
      decimal: /\./g,
    };
    const wageInfo = {
      frequency: 'hourly',
      amount: '20',
    };

    expect(convertPriceToTimeString(null, formatters, wageInfo)).toBe(null);
    expect(convertPriceToTimeString('$100.00', null, wageInfo)).toBe('$100.00');
    expect(convertPriceToTimeString('$100.00', formatters, null)).toBe('$100.00');
  });

  test('handles invalid price or wage values', () => {
    const formatters = {
      thousands: /,/g,
      decimal: /\./g,
    };
    const wageInfo = {
      frequency: 'hourly',
      amount: 'invalid', // Not a number
    };

    // Should return original price string when amount is invalid
    expect(convertPriceToTimeString('$100.00', formatters, wageInfo)).toBe('$100.00');

    // Should return original price string when price is not parsable
    expect(convertPriceToTimeString('not a price', formatters, wageInfo)).toBe('not a price');
  });

  test('handles different currency formats correctly', () => {
    const formatters = {
      thousands: /,/g,
      decimal: /\./g,
    };
    const wageInfo = {
      frequency: 'hourly',
      amount: '20',
    };

    // US Dollar format
    expect(convertPriceToTimeString('$100.00', formatters, wageInfo)).toBe('$100.00 (5h 0m)');
    // Euro format
    expect(convertPriceToTimeString('€100.00', formatters, wageInfo)).toBe('€100.00 (5h 0m)');
    // British Pound format
    expect(convertPriceToTimeString('£100.00', formatters, wageInfo)).toBe('£100.00 (5h 0m)');
    // Yen format (no decimal)
    expect(convertPriceToTimeString('¥10000', formatters, wageInfo)).toBe('¥10000 (500h 0m)');
  });

  test('handles different thousand/decimal separators', () => {
    // European format (space as thousands, comma as decimal)
    const europeFormatters = {
      thousands: /\s/g,
      decimal: /,/g,
    };
    const wageInfo = {
      frequency: 'hourly',
      amount: '20',
    };

    expect(convertPriceToTimeString('€100,00', europeFormatters, wageInfo)).toBe('€100,00 (5h 0m)');
    expect(convertPriceToTimeString('€1 234,56', europeFormatters, wageInfo)).toBe(
      '€1 234,56 (61h 44m)'
    );

    // Swiss format (apostrophe as thousands, dot as decimal)
    const swissFormatters = {
      thousands: /'/g,
      decimal: /\./g,
    };

    expect(convertPriceToTimeString("CHF 1'234.56", swissFormatters, wageInfo)).toBe(
      "CHF 1'234.56 (61h 44m)"
    );
  });

  test('handles complex price formats with multiple occurrences of separators', () => {
    const formatters = {
      thousands: /,/g,
      decimal: /\./g,
    };
    const wageInfo = {
      frequency: 'hourly',
      amount: '20',
    };

    // Multiple thousands separators
    expect(convertPriceToTimeString('$1,234,567.89', formatters, wageInfo)).toBe(
      '$1,234,567.89 (61728h 24m)'
    );
  });

  test('handles exceptions in the conversion process', () => {
    const formatters = {
      thousands: /,/g,
      decimal: /\./g,
    };

    // Create null hourly wage which would cause division by zero
    const badWageInfo = {
      frequency: 'hourly',
      amount: '0',
    };

    // Should handle division by zero gracefully
    expect(convertPriceToTimeString('$100.00', formatters, badWageInfo)).toBe('$100.00');

    // Non-parseable price string
    expect(
      convertPriceToTimeString('Not a price', formatters, {
        frequency: 'hourly',
        amount: '20',
      })
    ).toBe('Not a price');
  });
});

// ---------------------- From converter.unit.vitest.test.js ----------------------

/**
 * Tests for the converter.js utility
 */

describe('convertToTime', () => {
  // Hourly wage conversion tests
  test('converts prices with hourly wages - even division', () => {
    const hourlyRate = 20; // Using direct hourly rate
    const result = convertToTime(100, hourlyRate);

    expect(result.hours).toBe(5);
    expect(result.minutes).toBe(0);
  });

  test('converts prices with hourly wages - with fractional time', () => {
    const hourlyRate = 20; // Using direct hourly rate
    const result = convertToTime(30, hourlyRate);

    expect(result.hours).toBe(1);
    expect(result.minutes).toBe(30);
  });

  test('converts prices with hourly wages - small fraction', () => {
    const hourlyRate = 60; // Using direct hourly rate
    const result = convertToTime(5, hourlyRate);

    // 5/60 = 0.0833... hours = 5 minutes
    expect(result.hours).toBe(0);
    expect(result.minutes).toBe(5);
  });

  // Yearly wage conversion tests
  // (now pre-calculating the hourly rate instead of passing wage settings)
  test('converts prices with yearly wages', () => {
    const hourlyRate = 41600 / 2080; // 41600/2080 = $20/hour
    const result = convertToTime(100, hourlyRate);

    expect(result.hours).toBe(5);
    expect(result.minutes).toBe(0);
  });

  test('converts prices with yearly wages - with fractional time', () => {
    const hourlyRate = 41600 / 2080; // 41600/2080 = $20/hour
    const result = convertToTime(30, hourlyRate);

    expect(result.hours).toBe(1);
    expect(result.minutes).toBe(30);
  });

  // Edge cases
  test('handles zero price', () => {
    const hourlyRate = 20;
    const result = convertToTime(0, hourlyRate);

    expect(result.hours).toBe(0);
    expect(result.minutes).toBe(0);
  });

  test('handles very small prices', () => {
    const hourlyRate = 20;
    const result = convertToTime(0.01, hourlyRate);

    // 0.01/20 = 0.0005 hours = 0.03 minutes, which rounds to 0
    expect(result.hours).toBe(0);
    expect(result.minutes).toBe(0);
  });

  test('handles very large prices', () => {
    const hourlyRate = 20;
    const result = convertToTime(1000000, hourlyRate);

    // 1000000/20 = 50000 hours
    expect(result.hours).toBe(50000);
    expect(result.minutes).toBe(0);
  });

  test('handles very high wages', () => {
    const hourlyRate = 1000;
    const result = convertToTime(100, hourlyRate);

    // 100/1000 = 0.1 hours = 6 minutes
    expect(result.hours).toBe(0);
    expect(result.minutes).toBe(6);
  });

  test('handles very low wages', () => {
    const hourlyRate = 0.01;
    const result = convertToTime(1, hourlyRate);

    // 1/0.01 = 100 hours
    expect(result.hours).toBe(100);
    expect(result.minutes).toBe(0);
  });

  test('rounding minutes correctly', () => {
    const hourlyRate = 15;
    const result = convertToTime(7.5, hourlyRate);

    // 7.5/15 = 0.5 hours = 30 minutes
    expect(result.hours).toBe(0);
    expect(result.minutes).toBe(30);
  });
});

describe('formatTimeSnippet', () => {
  // Standard formatting tests
  test('formats hours and minutes', () => {
    expect(formatTimeSnippet(2, 30)).toBe('2 hours, 30 minutes');
  });

  // Hours only tests
  test('formats hours only', () => {
    expect(formatTimeSnippet(5, 0)).toBe('5 hours');
  });

  test('formats singular hour', () => {
    expect(formatTimeSnippet(1, 0)).toBe('1 hour');
  });

  // Minutes only tests
  test('formats minutes only', () => {
    expect(formatTimeSnippet(0, 45)).toBe('45 minutes');
  });

  test('formats singular minute', () => {
    expect(formatTimeSnippet(0, 1)).toBe('1 minute');
  });

  // Edge cases
  test('handles zero hours and zero minutes', () => {
    expect(formatTimeSnippet(0, 0)).toBe('0 minutes');
  });

  // Combined case with singular forms
  test('formats singular hour and singular minute', () => {
    expect(formatTimeSnippet(1, 1)).toBe('1 hour, 1 minute');
  });

  test('formats singular hour and plural minutes', () => {
    expect(formatTimeSnippet(1, 5)).toBe('1 hour, 5 minutes');
  });

  test('formats plural hours and singular minute', () => {
    expect(formatTimeSnippet(5, 1)).toBe('5 hours, 1 minute');
  });
});
