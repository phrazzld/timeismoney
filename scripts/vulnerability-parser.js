/**
 * Vulnerability parser for processing pnpm audit JSON output.
 * Converts raw audit results into structured vulnerability objects for security analysis.
 *
 * @file Vulnerability parser module for security audit system
 */

/**
 * Parses raw pnpm audit JSON output into structured vulnerability objects
 *
 * @param {string|object} auditData - Raw JSON string or parsed object from pnpm audit
 * @returns {Array<object>} Array of structured vulnerability objects
 * @throws {Error} When audit data is invalid or malformed
 */
export function parseVulnerabilities(auditData) {
  try {
    // Handle string input by parsing as JSON
    const data = typeof auditData === 'string' ? JSON.parse(auditData) : auditData;

    // Handle case where no vulnerabilities exist
    if (!data || !data.vulnerabilities || Object.keys(data.vulnerabilities).length === 0) {
      return [];
    }

    const vulnerabilities = [];
    const vulnData = data.vulnerabilities;

    // Process each vulnerability in the audit results
    for (const [packageName, vulnerability] of Object.entries(vulnData)) {
      // Skip null, undefined, or invalid vulnerability entries
      if (!vulnerability || typeof vulnerability !== 'object') {
        continue;
      }

      // Extract vulnerability details with safe defaults
      const parsedVuln = {
        id: generateVulnerabilityId(packageName, vulnerability),
        package: packageName,
        severity: vulnerability.severity || 'unknown',
        title: extractVulnerabilityTitle(vulnerability),
        description: extractVulnerabilityDescription(vulnerability),
        cves: extractCVEs(vulnerability),
        range: vulnerability.range || '*',
        via: extractViaArray(vulnerability.via),
        effects: vulnerability.effects || [],
        nodes: vulnerability.nodes || [],
        fixAvailable: Boolean(vulnerability.fixAvailable),
        isDirect: vulnerability.isDirect || false,
      };

      vulnerabilities.push(parsedVuln);
    }

    return vulnerabilities;
  } catch (error) {
    throw new Error(`Failed to parse vulnerability data: ${error.message}`);
  }
}

/**
 * Validates that audit data is in expected format
 *
 * @param {object} auditData - Parsed audit data object
 * @returns {boolean} True if data is valid audit format
 */
export function isValidAuditData(auditData) {
  try {
    // Basic structure validation
    if (!auditData || typeof auditData !== 'object') {
      return false;
    }

    // Check for required audit properties
    return 'vulnerabilities' in auditData || 'advisories' in auditData || 'metadata' in auditData;
  } catch {
    return false;
  }
}

/**
 * Filters vulnerabilities by severity levels
 *
 * @param {Array<object>} vulnerabilities - Array of vulnerability objects
 * @param {Array<string>} severityLevels - Array of severity levels to include
 * @returns {Array<object>} Filtered vulnerabilities matching severity criteria
 */
export function filterBySeverity(vulnerabilities, severityLevels) {
  if (!Array.isArray(vulnerabilities) || !Array.isArray(severityLevels)) {
    return [];
  }

  return vulnerabilities.filter((vuln) => severityLevels.includes(vuln.severity.toLowerCase()));
}

/**
 * Groups vulnerabilities by severity level
 *
 * @param {Array<object>} vulnerabilities - Array of vulnerability objects
 * @returns {object} Object with severity levels as keys and vulnerability arrays as values
 */
export function groupBySeverity(vulnerabilities) {
  if (!Array.isArray(vulnerabilities)) {
    return {};
  }

  return vulnerabilities.reduce((groups, vuln) => {
    const severity = vuln.severity.toLowerCase();
    if (!groups[severity]) {
      groups[severity] = [];
    }
    groups[severity].push(vuln);
    return groups;
  }, {});
}

// Helper functions for parsing vulnerability details

/**
 * Generates a unique identifier for a vulnerability
 *
 * @private
 * @param {string} packageName - Name of the affected package
 * @param {object} vulnerability - Vulnerability object
 * @returns {string} Unique vulnerability identifier
 */
function generateVulnerabilityId(packageName, vulnerability) {
  const timestamp = Date.now();
  const severityPrefix = (vulnerability.severity || 'unknown').charAt(0).toUpperCase();
  return `${severityPrefix}-${packageName.replace(/[^a-zA-Z0-9]/g, '')}-${timestamp}`;
}

/**
 * Extracts vulnerability title from various possible sources
 *
 * @private
 * @param {object} vulnerability - Vulnerability object
 * @returns {string} Vulnerability title or default message
 */
function extractVulnerabilityTitle(vulnerability) {
  return (
    vulnerability.title ||
    vulnerability.overview ||
    (vulnerability.via && vulnerability.via[0] && vulnerability.via[0].title) ||
    'Security vulnerability detected'
  );
}

/**
 * Extracts vulnerability description from various possible sources
 *
 * @private
 * @param {object} vulnerability - Vulnerability object
 * @returns {string} Vulnerability description or default message
 */
function extractVulnerabilityDescription(vulnerability) {
  return (
    vulnerability.description ||
    vulnerability.overview ||
    (vulnerability.via && vulnerability.via[0] && vulnerability.via[0].url) ||
    'No description available'
  );
}

/**
 * Extracts CVE identifiers from vulnerability data
 *
 * @private
 * @param {object} vulnerability - Vulnerability object
 * @returns {Array<string>} Array of CVE identifiers
 */
function extractCVEs(vulnerability) {
  const cves = [];

  if (vulnerability.cves) {
    cves.push(...vulnerability.cves);
  }

  if (vulnerability.via && Array.isArray(vulnerability.via)) {
    vulnerability.via.forEach((via) => {
      if (via.cve) {
        cves.push(via.cve);
      }
    });
  }

  return [...new Set(cves)]; // Remove duplicates
}

/**
 * Extracts and normalizes the 'via' array from vulnerability data
 *
 * @private
 * @param {Array|object} via - Via data from vulnerability
 * @returns {Array} Normalized via array
 */
function extractViaArray(via) {
  if (!via) return [];
  if (Array.isArray(via)) return via;
  return [via];
}
